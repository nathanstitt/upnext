#include <functional>#include <iostream>#include <stdlib.h>#include <string.h>#include <sstream>#include <algorithm>#include <ctime>#include "time.h"#include "fmt/format.h"#include "fmt/chrono.h"// #include "fmt/compile.h"#include "lvgl.h"#include "calendar_events.h"#include "upnext.h"#include "esp_log.h"static const char *TAG = "cal";using json = nlohmann::json;using namespace std::chrono;const char* ISO_DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.000Z";const std::string API_BASE_URL       = "https://www.googleapis.com/calendar/v3";const std::string AUTH_BASE_URL      = "https://accounts.google.com/o/oauth2/auth";const std::string REDIRECT_URI    = "http://192.168.1.1:2342";  // foo.stitt.org:9333urn:ietf:wg:oauth:2.0:oob";std::time_t strToTimeT(std::string time) {    std::tm tm = {};    //std::stringstream ss(utcDate);    std::stringstream ss(time);    ss >> std::get_time(&tm, ISO_DATE_FORMAT);    if (ss.fail()) {        return 0;    }    auto statm = mktime(&tm);//    std::chrono::sys_time<std::chrono::seconds> tp = std::chrono::system_clock::from_time_t(startTime);    auto local = std::localtime(&statm);    auto tt = std::mktime(local);    return tt;}// Duration::Duration(uint16_t mins)// : minutes(mins) { }// Duration::Duration(Duration &other): minutes(other.minutes) {}std::string timeToStr(std::time_t tt) {    // Convert to tm struct for local time    struct tm tm;    localtime_r(&tt, &tm);    std::cout << "HOUR: " << tm.tm_hour << std::endl;    return fmt::format("{:d}:{:02d}{}",                       tm.tm_hour > 12 ? tm.tm_hour - 12 : tm.tm_hour,                       tm.tm_min,                       tm.tm_hour > 12 ? "pm" : "am"                       );}std::string pluralize(uint16_t qty, std::string label) {    std::string ret(label);    if (qty > 1) ret += "s";    return ret;}std::string durationStr(int32_t minutes) {    std::ostringstream os;//    os <<  "In ";    // simplest case is just X minute(s)    if (minutes < 30) {        os << minutes << pluralize(minutes, " minute");        return os.str();    }    auto dv = std::div(static_cast<int>(minutes), 60);    std::string fraction("");    if (dv.rem > 50) {        dv.quot += 1;    } else if (dv.rem > 35) {        fraction = "¾";    } else if (dv.rem > 25) {        fraction = "½";    } else if (dv.rem > 10) {        fraction = "¼";    }    if (dv.quot > 0) {        os << dv.quot << fraction << pluralize(dv.quot, " hour");    } else {        os << fraction << " hour";    }    return os.str();}// CalendarEvent::CalendarEvent() {//     std::string startAt("2023-11-15T20:00:00.000Z");//     std::cout << "STA: " << startAt << std::endl;//     //string utcDate("2023-11-15T08:30:00Z");//     //    2023-11-15T20:00:00.000Z//     std::tm tm = {};//     //std::stringstream ss(utcDate);//     std::stringstream ss(startAt);//     ss >> std::get_time(&tm, ISO_DATE_FORMAT);//     if (ss.fail()) {//         throw std::runtime_error("Failed to parse date: " + startAt);//     }//     auto st = timegm(&tm);//     //    std::chrono::sys_time<std::chrono::seconds> tp = std::chrono::system_clock::from_time_t(startTime);//     auto local = std::localtime(&this->startTime);//     // std::time_t local = std::mktime(std::localtime(&this->startTime));//     //    std::chrono::zoned_time<std::chrono::seconds> cst_time{"America/Chicago", tp};//     //  return cst_time;//     std::cout << "PARSED AS: " << startTime << " : " << tm.tm_hour << " local: " << std::put_time(std::localtime(&startTime), "%c %Z") << std::endl;// }CalendarEvent::CalendarEvent(json ev): _event(ev) {}std::time_t CalendarEvent::startTime() const {    if (_startTime) {        return _startTime;    }    return _startTime = strToTimeT(_event["startAt"].template get<std::string>());}std::string CalendarEvent::startHHMM() const {    return timeToStr(this->startTime());}std::string CalendarEvent::endHHMM() const {    return timeToStr(this->endTime());    // auto et = this->startTime();    // std::tm local_time = *std::localtime(&et);    // auto time_str = fmt::format("{:%-I:%M%p}", local_time);    // std::transform(time_str.begin(), time_str.end(), time_str.begin(),    //                [](unsigned char c) { return std::tolower(c); });    // return time_str;}std::time_t CalendarEvent::endTime() const {    if (_endTime) {        return _endTime;    }    return _endTime = strToTimeT(_event["endAt"].template get<std::string>());}CalendarEvent::CalendarEvent(CalendarEvent &other): _event(other._event) { }bool CalendarEvent::isActive(std::time_t currentTime) const {    auto active = (currentTime >= startTime() && currentTime <= endTime());//    std::cout << "isactive: " << active <<  " : " << currentTime << " >= " << startTime() << std::endl;    return active;}bool CalendarEvent::isNearlyActive() const {    auto now = std::chrono::system_clock::now();    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);    std::cout << "nearlyActive " << currentTime << " + " << UPCOMING_SECONDS << " >= " << startTime() << std::endl;    return !isActive(currentTime) && ((currentTime + UPCOMING_SECONDS) >= startTime());}std::string CalendarEvent::title() const {    auto title = _event["title"].template get<std::string>();    return title;}std::time_t CalendarEvents::now() {    auto now = std::chrono::system_clock::now();    std::time_t now_c = std::chrono::system_clock::to_time_t(now);    return now_c;}std::string CalendarEvents::nowStr() {    auto now = std::chrono::system_clock::now();    // Convert to time_t for conversion to local time    std::time_t nw = std::chrono::system_clock::to_time_t(now);    //std::tm local_time = *std::localtime(&nw);    return timeToStr(nw);    // // Convert to tm struct for local time    // std::tm tm = *std::localtime(&now_t);    // std::cout << "NOW STR: " << now_t << std::endl;    // // Format and print the local time using fmt::format    // std::string formatted_time = fmt::format("{:d}:{:02d}{}",    //                                          tm.tm_hour > 12 ? tm.tm_hour - 12 : tm.tm_hour,    //                                          tm.tm_min,    //                                          tm.tm_hour > 12 ? "pm" : "am"    //                                          );    // std::cout << "local tm: " << formatted_time << std::endl;    // return formatted_time;//     auto nw = this->now();//     std::tm local_time = *std::localtime(&nw);//     std::string    time_str   = "12:23pm"; //  fmt::format("{:%-I}:{:%M%p}", local_time, local_time);//   //  std::cout << "TIME: " << time_str << std::endl;//     std::transform(time_str.begin(), time_str.end(), time_str.begin(),//                    [](unsigned char c) { return std::tolower(c); });//     return time_str;}std::string CalendarEvent::duration() {    auto now = system_clock::now();    auto now_t = std::chrono::system_clock::to_time_t(now);    auto startingMinutes = (startTime() - now_t) / 60;    auto endingMinutes = (endTime() - now_t) / 60;    std::ostringstream os;    if (startingMinutes < 0) {        os << "Until " << this->endHHMM() << " (" << durationStr(endingMinutes) << ")";    }    if (startingMinutes == 0) {        os << "starting, ending in " << durationStr(endingMinutes);    }    if (startingMinutes > 0) {        if (startingMinutes > UPCOMING_MINS) {            os << "Free time for ";        } else {            os << "In ";        }        os << durationStr(startingMinutes) ; // << ", lasts " << durationStr(endingMinutes - startingMinutes);    }    return os.str();    // auto st      = startTime();    // auto nt = std::localtime(&now_t);    // std::cout << " nowtime " << std::put_time(nt, "%c %Z") << std::endl;    // std::tm* ltm = std::localtime(&st);    // std::cout << " localtime " << std::put_time(ltm, "%c %Z") << std::endl;    // std::cout << " minutes: " << minutes << std::endl;}// string CalendarEvent::duration() {//     auto mins = minutes();//     if (mins > 50) {//         return "1";//     }//     return "20";// };CalendarEvents::CalendarEvents(Network* n): network(n) { };// CalendarEvent* CalendarEvents::currentCalendarEvent() {//     if (events.empty()) {//         return NULL;//     }//     return events.at(0);// }CalendarEvent* CalendarEvents::currentEvent() const {    std::time_t currentTime = std::time(nullptr); // Get current time    for (CalendarEvent* event : events) {        if (event != nullptr && event->isActive(currentTime)) {            return event;        }    }    return nullptr;}CalendarEvent* CalendarEvents::upcomingEvent() {    std::time_t currentTime = std::time(nullptr); // Get current time    for (CalendarEvent* event : events) {        if (event != nullptr && !event->isActive(currentTime)) {            return event;        }    }    return nullptr;}bool CalendarEvents::tick() {    auto now = std::chrono::steady_clock::now();    if (std::chrono::duration_cast<std::chrono::minutes>(now - last_poll).count() < 10) {        return false;    }    last_poll = std::chrono::steady_clock::now();    auto jsonCalendarEvents = network->gcalEvents();    ESP_LOGI(TAG, "Polling for CalendarEvents");    events.clear();    for (auto& jsonCalendarEvent : jsonCalendarEvents) {        auto event = new CalendarEvent(jsonCalendarEvent);        events.push_back(event);        auto title = jsonCalendarEvent["title"].template get<std::string>();        ESP_LOGI(TAG, "event: %s", title.c_str());    }    std::sort(events.begin(), events.end(), [](const CalendarEvent* a, const CalendarEvent* b) {        return a->startTime() < b->startTime();    });    return true;}